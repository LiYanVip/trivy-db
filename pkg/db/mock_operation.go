// Code generated by mockery v1.0.0. DO NOT EDIT.

package db

import (
	types "github.com/aquasecurity/trivy-db/pkg/types"
	mock "github.com/stretchr/testify/mock"
	bbolt "go.etcd.io/bbolt"
)

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

type OperationBatchUpdateArgs struct {
	Fn         func(*bbolt.Tx) error
	FnAnything bool
}

type OperationBatchUpdateReturns struct {
	Err error
}

type OperationBatchUpdateExpectation struct {
	Args    OperationBatchUpdateArgs
	Returns OperationBatchUpdateReturns
}

func (_m *MockOperation) ApplyBatchUpdateExpectation(e OperationBatchUpdateExpectation) {
	var args []interface{}
	if e.Args.FnAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Fn)
	}
	_m.On("BatchUpdate", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyBatchUpdateExpectations(expectations []OperationBatchUpdateExpectation) {
	for _, e := range expectations {
		_m.ApplyBatchUpdateExpectation(e)
	}
}

// BatchUpdate provides a mock function with given fields: fn
func (_m *MockOperation) BatchUpdate(fn func(*bbolt.Tx) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationDeleteAdvisoryDetailBucketReturns struct {
	_a0 error
}

type OperationDeleteAdvisoryDetailBucketExpectation struct {
	Returns OperationDeleteAdvisoryDetailBucketReturns
}

func (_m *MockOperation) ApplyDeleteAdvisoryDetailBucketExpectation(e OperationDeleteAdvisoryDetailBucketExpectation) {
	var args []interface{}
	_m.On("DeleteAdvisoryDetailBucket", args...).Return(e.Returns._a0)
}

func (_m *MockOperation) ApplyDeleteAdvisoryDetailBucketExpectations(expectations []OperationDeleteAdvisoryDetailBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteAdvisoryDetailBucketExpectation(e)
	}
}

// DeleteAdvisoryDetailBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteAdvisoryDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationDeleteSeverityBucketReturns struct {
	Err error
}

type OperationDeleteSeverityBucketExpectation struct {
	Returns OperationDeleteSeverityBucketReturns
}

func (_m *MockOperation) ApplyDeleteSeverityBucketExpectation(e OperationDeleteSeverityBucketExpectation) {
	var args []interface{}
	_m.On("DeleteSeverityBucket", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDeleteSeverityBucketExpectations(expectations []OperationDeleteSeverityBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteSeverityBucketExpectation(e)
	}
}

// DeleteSeverityBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteSeverityBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationDeleteVulnerabilityDetailBucketReturns struct {
	Err error
}

type OperationDeleteVulnerabilityDetailBucketExpectation struct {
	Returns OperationDeleteVulnerabilityDetailBucketReturns
}

func (_m *MockOperation) ApplyDeleteVulnerabilityDetailBucketExpectation(e OperationDeleteVulnerabilityDetailBucketExpectation) {
	var args []interface{}
	_m.On("DeleteVulnerabilityDetailBucket", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyDeleteVulnerabilityDetailBucketExpectations(expectations []OperationDeleteVulnerabilityDetailBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteVulnerabilityDetailBucketExpectation(e)
	}
}

// DeleteVulnerabilityDetailBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteVulnerabilityDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationForEachAdvisoryArgs struct {
	Source          string
	SourceAnything  bool
	PkgName         string
	PkgNameAnything bool
}

type OperationForEachAdvisoryReturns struct {
	Value map[string][]byte
	Err   error
}

type OperationForEachAdvisoryExpectation struct {
	Args    OperationForEachAdvisoryArgs
	Returns OperationForEachAdvisoryReturns
}

func (_m *MockOperation) ApplyForEachAdvisoryExpectation(e OperationForEachAdvisoryExpectation) {
	var args []interface{}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	_m.On("ForEachAdvisory", args...).Return(e.Returns.Value, e.Returns.Err)
}

func (_m *MockOperation) ApplyForEachAdvisoryExpectations(expectations []OperationForEachAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachAdvisoryExpectation(e)
	}
}

// ForEachAdvisory provides a mock function with given fields: source, pkgName
func (_m *MockOperation) ForEachAdvisory(source string, pkgName string) (map[string][]byte, error) {
	ret := _m.Called(source, pkgName)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(string, string) map[string][]byte); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationForEachSeverityArgs struct {
	Fn         func(*bbolt.Tx, string, types.Severity) error
	FnAnything bool
}

type OperationForEachSeverityReturns struct {
	Err error
}

type OperationForEachSeverityExpectation struct {
	Args    OperationForEachSeverityArgs
	Returns OperationForEachSeverityReturns
}

func (_m *MockOperation) ApplyForEachSeverityExpectation(e OperationForEachSeverityExpectation) {
	var args []interface{}
	if e.Args.FnAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Fn)
	}
	_m.On("ForEachSeverity", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyForEachSeverityExpectations(expectations []OperationForEachSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachSeverityExpectation(e)
	}
}

// ForEachSeverity provides a mock function with given fields: fn
func (_m *MockOperation) ForEachSeverity(fn func(*bbolt.Tx, string, types.Severity) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx, string, types.Severity) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationGetAdvisoriesArgs struct {
	Source          string
	SourceAnything  bool
	PkgName         string
	PkgNameAnything bool
}

type OperationGetAdvisoriesReturns struct {
	Advisories []types.Advisory
	Err        error
}

type OperationGetAdvisoriesExpectation struct {
	Args    OperationGetAdvisoriesArgs
	Returns OperationGetAdvisoriesReturns
}

func (_m *MockOperation) ApplyGetAdvisoriesExpectation(e OperationGetAdvisoriesExpectation) {
	var args []interface{}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	_m.On("GetAdvisories", args...).Return(e.Returns.Advisories, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetAdvisoriesExpectations(expectations []OperationGetAdvisoriesExpectation) {
	for _, e := range expectations {
		_m.ApplyGetAdvisoriesExpectation(e)
	}
}

// GetAdvisories provides a mock function with given fields: source, pkgName
func (_m *MockOperation) GetAdvisories(source string, pkgName string) ([]types.Advisory, error) {
	ret := _m.Called(source, pkgName)

	var r0 []types.Advisory
	if rf, ok := ret.Get(0).(func(string, string) []types.Advisory); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Advisory)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetRedHatCPEsArgs struct {
	Repository         string
	RepositoryAnything bool
}

type OperationGetRedHatCPEsReturns struct {
	Cpes []string
	Err  error
}

type OperationGetRedHatCPEsExpectation struct {
	Args    OperationGetRedHatCPEsArgs
	Returns OperationGetRedHatCPEsReturns
}

func (_m *MockOperation) ApplyGetRedHatCPEsExpectation(e OperationGetRedHatCPEsExpectation) {
	var args []interface{}
	if e.Args.RepositoryAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Repository)
	}
	_m.On("GetRedHatCPEs", args...).Return(e.Returns.Cpes, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetRedHatCPEsExpectations(expectations []OperationGetRedHatCPEsExpectation) {
	for _, e := range expectations {
		_m.ApplyGetRedHatCPEsExpectation(e)
	}
}

// GetRedHatCPEs provides a mock function with given fields: repository
func (_m *MockOperation) GetRedHatCPEs(repository string) ([]string, error) {
	ret := _m.Called(repository)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(repository)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(repository)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetSeverityArgs struct {
	VulnerabilityID         string
	VulnerabilityIDAnything bool
}

type OperationGetSeverityReturns struct {
	Severity types.Severity
	Err      error
}

type OperationGetSeverityExpectation struct {
	Args    OperationGetSeverityArgs
	Returns OperationGetSeverityReturns
}

func (_m *MockOperation) ApplyGetSeverityExpectation(e OperationGetSeverityExpectation) {
	var args []interface{}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	_m.On("GetSeverity", args...).Return(e.Returns.Severity, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetSeverityExpectations(expectations []OperationGetSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetSeverityExpectation(e)
	}
}

// GetSeverity provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetSeverity(vulnerabilityID string) (types.Severity, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Severity
	if rf, ok := ret.Get(0).(func(string) types.Severity); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Severity)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetVulnerabilityArgs struct {
	VulnerabilityID         string
	VulnerabilityIDAnything bool
}

type OperationGetVulnerabilityReturns struct {
	Vulnerability types.Vulnerability
	Err           error
}

type OperationGetVulnerabilityExpectation struct {
	Args    OperationGetVulnerabilityArgs
	Returns OperationGetVulnerabilityReturns
}

func (_m *MockOperation) ApplyGetVulnerabilityExpectation(e OperationGetVulnerabilityExpectation) {
	var args []interface{}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	_m.On("GetVulnerability", args...).Return(e.Returns.Vulnerability, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetVulnerabilityExpectations(expectations []OperationGetVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetVulnerabilityExpectation(e)
	}
}

// GetVulnerability provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetVulnerability(vulnerabilityID string) (types.Vulnerability, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Vulnerability
	if rf, ok := ret.Get(0).(func(string) types.Vulnerability); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Vulnerability)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationGetVulnerabilityDetailArgs struct {
	CveID         string
	CveIDAnything bool
}

type OperationGetVulnerabilityDetailReturns struct {
	Detail map[string]types.VulnerabilityDetail
	Err    error
}

type OperationGetVulnerabilityDetailExpectation struct {
	Args    OperationGetVulnerabilityDetailArgs
	Returns OperationGetVulnerabilityDetailReturns
}

func (_m *MockOperation) ApplyGetVulnerabilityDetailExpectation(e OperationGetVulnerabilityDetailExpectation) {
	var args []interface{}
	if e.Args.CveIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.CveID)
	}
	_m.On("GetVulnerabilityDetail", args...).Return(e.Returns.Detail, e.Returns.Err)
}

func (_m *MockOperation) ApplyGetVulnerabilityDetailExpectations(expectations []OperationGetVulnerabilityDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyGetVulnerabilityDetailExpectation(e)
	}
}

// GetVulnerabilityDetail provides a mock function with given fields: cveID
func (_m *MockOperation) GetVulnerabilityDetail(cveID string) (map[string]types.VulnerabilityDetail, error) {
	ret := _m.Called(cveID)

	var r0 map[string]types.VulnerabilityDetail
	if rf, ok := ret.Get(0).(func(string) map[string]types.VulnerabilityDetail); ok {
		r0 = rf(cveID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.VulnerabilityDetail)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(cveID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type OperationPutAdvisoryDetailArgs struct {
	Tx                     *bbolt.Tx
	TxAnything             bool
	VulnID                 string
	VulnIDAnything         bool
	PkgName                string
	PkgNameAnything        bool
	NestedBktNames         []string
	NestedBktNamesAnything bool
	Advisory               interface{}
	AdvisoryAnything       bool
}

type OperationPutAdvisoryDetailReturns struct {
	Err error
}

type OperationPutAdvisoryDetailExpectation struct {
	Args    OperationPutAdvisoryDetailArgs
	Returns OperationPutAdvisoryDetailReturns
}

func (_m *MockOperation) ApplyPutAdvisoryDetailExpectation(e OperationPutAdvisoryDetailExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnID)
	}
	if e.Args.PkgNameAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.PkgName)
	}
	if e.Args.NestedBktNamesAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.NestedBktNames)
	}
	if e.Args.AdvisoryAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Advisory)
	}
	_m.On("PutAdvisoryDetail", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutAdvisoryDetailExpectations(expectations []OperationPutAdvisoryDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyPutAdvisoryDetailExpectation(e)
	}
}

// PutAdvisoryDetail provides a mock function with given fields: tx, vulnID, pkgName, nestedBktNames, advisory
func (_m *MockOperation) PutAdvisoryDetail(tx *bbolt.Tx, vulnID string, pkgName string, nestedBktNames []string, advisory interface{}) error {
	ret := _m.Called(tx, vulnID, pkgName, nestedBktNames, advisory)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, []string, interface{}) error); ok {
		r0 = rf(tx, vulnID, pkgName, nestedBktNames, advisory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutRedHatCPEsArgs struct {
	Tx                 *bbolt.Tx
	TxAnything         bool
	Repository         string
	RepositoryAnything bool
	Cpes               []string
	CpesAnything       bool
}

type OperationPutRedHatCPEsReturns struct {
	Err error
}

type OperationPutRedHatCPEsExpectation struct {
	Args    OperationPutRedHatCPEsArgs
	Returns OperationPutRedHatCPEsReturns
}

func (_m *MockOperation) ApplyPutRedHatCPEsExpectation(e OperationPutRedHatCPEsExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.RepositoryAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Repository)
	}
	if e.Args.CpesAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Cpes)
	}
	_m.On("PutRedHatCPEs", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutRedHatCPEsExpectations(expectations []OperationPutRedHatCPEsExpectation) {
	for _, e := range expectations {
		_m.ApplyPutRedHatCPEsExpectation(e)
	}
}

// PutRedHatCPEs provides a mock function with given fields: tx, repository, cpes
func (_m *MockOperation) PutRedHatCPEs(tx *bbolt.Tx, repository string, cpes []string) error {
	ret := _m.Called(tx, repository, cpes)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, []string) error); ok {
		r0 = rf(tx, repository, cpes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutSeverityArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Severity                types.Severity
	SeverityAnything        bool
}

type OperationPutSeverityReturns struct {
	Err error
}

type OperationPutSeverityExpectation struct {
	Args    OperationPutSeverityArgs
	Returns OperationPutSeverityReturns
}

func (_m *MockOperation) ApplyPutSeverityExpectation(e OperationPutSeverityExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SeverityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Severity)
	}
	_m.On("PutSeverity", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutSeverityExpectations(expectations []OperationPutSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutSeverityExpectation(e)
	}
}

// PutSeverity provides a mock function with given fields: tx, vulnerabilityID, severity
func (_m *MockOperation) PutSeverity(tx *bbolt.Tx, vulnerabilityID string, severity types.Severity) error {
	ret := _m.Called(tx, vulnerabilityID, severity)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Severity) error); ok {
		r0 = rf(tx, vulnerabilityID, severity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutVulnerabilityArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Vulnerability           types.Vulnerability
	VulnerabilityAnything   bool
}

type OperationPutVulnerabilityReturns struct {
	Err error
}

type OperationPutVulnerabilityExpectation struct {
	Args    OperationPutVulnerabilityArgs
	Returns OperationPutVulnerabilityReturns
}

func (_m *MockOperation) ApplyPutVulnerabilityExpectation(e OperationPutVulnerabilityExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.VulnerabilityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulnerability)
	}
	_m.On("PutVulnerability", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutVulnerabilityExpectations(expectations []OperationPutVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityExpectation(e)
	}
}

// PutVulnerability provides a mock function with given fields: tx, vulnerabilityID, vulnerability
func (_m *MockOperation) PutVulnerability(tx *bbolt.Tx, vulnerabilityID string, vulnerability types.Vulnerability) error {
	ret := _m.Called(tx, vulnerabilityID, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Vulnerability) error); ok {
		r0 = rf(tx, vulnerabilityID, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationPutVulnerabilityDetailArgs struct {
	Tx                      *bbolt.Tx
	TxAnything              bool
	VulnerabilityID         string
	VulnerabilityIDAnything bool
	Source                  string
	SourceAnything          bool
	Vulnerability           types.VulnerabilityDetail
	VulnerabilityAnything   bool
}

type OperationPutVulnerabilityDetailReturns struct {
	Err error
}

type OperationPutVulnerabilityDetailExpectation struct {
	Args    OperationPutVulnerabilityDetailArgs
	Returns OperationPutVulnerabilityDetailReturns
}

func (_m *MockOperation) ApplyPutVulnerabilityDetailExpectation(e OperationPutVulnerabilityDetailExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.VulnerabilityIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.VulnerabilityID)
	}
	if e.Args.SourceAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Source)
	}
	if e.Args.VulnerabilityAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Vulnerability)
	}
	_m.On("PutVulnerabilityDetail", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplyPutVulnerabilityDetailExpectations(expectations []OperationPutVulnerabilityDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityDetailExpectation(e)
	}
}

// PutVulnerabilityDetail provides a mock function with given fields: tx, vulnerabilityID, source, vulnerability
func (_m *MockOperation) PutVulnerabilityDetail(tx *bbolt.Tx, vulnerabilityID string, source string, vulnerability types.VulnerabilityDetail) error {
	ret := _m.Called(tx, vulnerabilityID, source, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, types.VulnerabilityDetail) error); ok {
		r0 = rf(tx, vulnerabilityID, source, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type OperationSaveAdvisoryDetailsArgs struct {
	Tx            *bbolt.Tx
	TxAnything    bool
	CveID         string
	CveIDAnything bool
}

type OperationSaveAdvisoryDetailsReturns struct {
	Err error
}

type OperationSaveAdvisoryDetailsExpectation struct {
	Args    OperationSaveAdvisoryDetailsArgs
	Returns OperationSaveAdvisoryDetailsReturns
}

func (_m *MockOperation) ApplySaveAdvisoryDetailsExpectation(e OperationSaveAdvisoryDetailsExpectation) {
	var args []interface{}
	if e.Args.TxAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.Tx)
	}
	if e.Args.CveIDAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.CveID)
	}
	_m.On("SaveAdvisoryDetails", args...).Return(e.Returns.Err)
}

func (_m *MockOperation) ApplySaveAdvisoryDetailsExpectations(expectations []OperationSaveAdvisoryDetailsExpectation) {
	for _, e := range expectations {
		_m.ApplySaveAdvisoryDetailsExpectation(e)
	}
}

// SaveAdvisoryDetails provides a mock function with given fields: tx, cveID
func (_m *MockOperation) SaveAdvisoryDetails(tx *bbolt.Tx, cveID string) error {
	ret := _m.Called(tx, cveID)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string) error); ok {
		r0 = rf(tx, cveID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
